{"ast":null,"code":"export function blur(values, r) {\n  if (!((r = +r) >= 0)) throw new RangeError(\"invalid r\");\n  var length = values.length;\n  if (!((length = Math.floor(length)) >= 0)) throw new RangeError(\"invalid length\");\n  if (!length || !r) return values;\n  var blur = blurf(r);\n  var temp = values.slice();\n  blur(values, temp, 0, length, 1);\n  blur(temp, values, 0, length, 1);\n  blur(values, temp, 0, length, 1);\n  return values;\n}\nexport var blur2 = Blur2(blurf);\nexport var blurImage = Blur2(blurfImage);\nfunction Blur2(blur) {\n  return function (data, rx) {\n    var ry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rx;\n    if (!((rx = +rx) >= 0)) throw new RangeError(\"invalid rx\");\n    if (!((ry = +ry) >= 0)) throw new RangeError(\"invalid ry\");\n    var values = data.data,\n      width = data.width,\n      height = data.height;\n    if (!((width = Math.floor(width)) >= 0)) throw new RangeError(\"invalid width\");\n    if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError(\"invalid height\");\n    if (!width || !height || !rx && !ry) return data;\n    var blurx = rx && blur(rx);\n    var blury = ry && blur(ry);\n    var temp = values.slice();\n    if (blurx && blury) {\n      blurh(blurx, temp, values, width, height);\n      blurh(blurx, values, temp, width, height);\n      blurh(blurx, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n      blurv(blury, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n    } else if (blurx) {\n      blurh(blurx, values, temp, width, height);\n      blurh(blurx, temp, values, width, height);\n      blurh(blurx, values, temp, width, height);\n    } else if (blury) {\n      blurv(blury, values, temp, width, height);\n      blurv(blury, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n    }\n    return data;\n  };\n}\nfunction blurh(blur, T, S, w, h) {\n  for (var y = 0, n = w * h; y < n;) {\n    blur(T, S, y, y += w, 1);\n  }\n}\nfunction blurv(blur, T, S, w, h) {\n  for (var x = 0, n = w * h; x < w; ++x) {\n    blur(T, S, x, x + n, w);\n  }\n}\nfunction blurfImage(radius) {\n  var blur = blurf(radius);\n  return function (T, S, start, stop, step) {\n    start <<= 2, stop <<= 2, step <<= 2;\n    blur(T, S, start + 0, stop + 0, step);\n    blur(T, S, start + 1, stop + 1, step);\n    blur(T, S, start + 2, stop + 2, step);\n    blur(T, S, start + 3, stop + 3, step);\n  };\n}\n\n// Given a target array T, a source array S, sets each value T[i] to the average\n// of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,\n// for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between\n// S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an\n// integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted\n// according to r - ⌊radius⌋.\nfunction blurf(radius) {\n  var radius0 = Math.floor(radius);\n  if (radius0 === radius) return bluri(radius);\n  var t = radius - radius0;\n  var w = 2 * radius + 1;\n  return function (T, S, start, stop, step) {\n    // stop must be aligned!\n    if (!((stop -= step) >= start)) return; // inclusive stop\n    var sum = radius0 * S[start];\n    var s0 = step * radius0;\n    var s1 = s0 + step;\n    for (var i = start, j = start + s0; i < j; i += step) {\n      sum += S[Math.min(stop, i)];\n    }\n    for (var _i = start, _j = stop; _i <= _j; _i += step) {\n      sum += S[Math.min(stop, _i + s0)];\n      T[_i] = (sum + t * (S[Math.max(start, _i - s1)] + S[Math.min(stop, _i + s1)])) / w;\n      sum -= S[Math.max(start, _i - s0)];\n    }\n  };\n}\n\n// Like blurf, but optimized for integer radius.\nfunction bluri(radius) {\n  var w = 2 * radius + 1;\n  return function (T, S, start, stop, step) {\n    // stop must be aligned!\n    if (!((stop -= step) >= start)) return; // inclusive stop\n    var sum = radius * S[start];\n    var s = step * radius;\n    for (var i = start, j = start + s; i < j; i += step) {\n      sum += S[Math.min(stop, i)];\n    }\n    for (var _i2 = start, _j2 = stop; _i2 <= _j2; _i2 += step) {\n      sum += S[Math.min(stop, _i2 + s)];\n      T[_i2] = sum / w;\n      sum -= S[Math.max(start, _i2 - s)];\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}